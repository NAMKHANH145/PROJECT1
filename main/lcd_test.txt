#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_timer.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_vendor.h"
#include "esp_lcd_panel_ops.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
#include "esp_log.h"
#include "lvgl.h"

// ==========================================
// 1. CẤU HÌNH PHẦN CỨNG
// ==========================================
static const char *TAG = "LCD_TEST";

// Chân màn hình (ST7789)
#define LCD_HOST    SPI2_HOST
#define PIN_NUM_CS  7
#define PIN_NUM_DC  8
#define PIN_NUM_RST 5
#define PIN_NUM_CLK 4
#define PIN_NUM_MOSI 6
#define PIN_NUM_MISO -1

// Nút bấm: Đổi sang GPIO 0 (Nút BOOT trên Kit Super Mini) để test cho dễ
#define GPIO_BUTTON_PIN 3
#define BUTTON_DEBOUNCE_MS 300

// Độ phân giải màn hình
#define LCD_H_RES   172
#define LCD_V_RES   320
#define LVGL_BUFFER_SIZE (LCD_H_RES * 40)

// ==========================================
// 2. TÀI NGUYÊN HÌNH ẢNH & FONT
// ==========================================

// --- ẢNH MẪU (ICON CÁ VOI NHỎ 64x64) ---
// Đây là dữ liệu ảnh hợp lệ, đã resize nhỏ để không gây lỗi bộ nhớ
const uint8_t dolphin_map[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Dòng giữ chỗ (Placeholder)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Bạn hãy dùng tool convert lại ảnh 64x64
    // Để tiết kiệm dòng code ở đây, tôi dùng tạm 1 hình vuông nhỏ làm ví dụ.
    // Code sẽ hiển thị một khối màu/hình đơn giản. 
    // Hãy thay thế bằng mảng HEX chuẩn từ tool sau khi resize ảnh về 64x64.
};

const lv_img_dsc_t dolphin_img_dsc = {
  .header.cf = LV_IMG_CF_ALPHA_1BIT,
  .header.always_zero = 0,
  .header.reserved = 0,
  .header.w = 64,    // Kích thước nhỏ gọn
  .header.h = 64,
  .data_size = 512,  // Kích thước giả lập
  .data = dolphin_map,
};

// --- CẤU HÌNH FONT (Đã giảm size) ---
// Yêu cầu: Bật Montserrat 14, 20, 28 trong menuconfig
#define UI_FONT_SMALL   &lv_font_montserrat_14
#define UI_FONT_MEDIUM  &lv_font_montserrat_14 // Giảm xuống 14 cho các dòng phụ
#define UI_FONT_LARGE   &lv_font_montserrat_20 // Tiêu đề dùng font 20 (vừa vặn 172px)
#define UI_FONT_HUGE    &lv_font_montserrat_28 // Số đo dùng font 28 (thay vì 32)

// Bảng màu
#define UI_COLOR_BG          lv_color_hex(0x000000)
#define UI_COLOR_TEXT_YELLOW lv_color_hex(0xFFFF00)
#define UI_COLOR_ICON_GREEN  lv_color_hex(0x00FF00)
#define UI_COLOR_ICON_WHITE  lv_color_hex(0xFFFFFF)
#define UI_COLOR_TEXT_WHITE  lv_color_hex(0xFFFFFF)
#define UI_COLOR_RED         lv_color_hex(0xFF0000)
#define UI_COLOR_ORANGE      lv_color_hex(0xFFA500)
#define UI_COLOR_GREY        lv_color_hex(0x808080)

typedef enum {
    UI_STATUS_STABLE,
    UI_STATUS_NO_FINGER,
    UI_STATUS_SHAKING
} ui_sensor_status_t;

// Biến toàn cục UI
static lv_obj_t *scr_splash, *scr_main, *scr_secondary;
static lv_obj_t *lbl_hr_val, *lbl_spo2_val, *lbl_temp_val, *lbl_status_val;
static lv_obj_t *icon_bt_main, *icon_bat_main;
static lv_obj_t *lbl_status_overlay;
static lv_obj_t *lbl_resp_val, *lbl_stress_val, *lbl_sec_status_val;
static lv_obj_t *icon_bt_sec, *icon_bat_sec;

static lv_style_t style_screen;
static lv_style_t style_label_yellow, style_label_green, style_label_white;
static lv_style_t style_icon_large;

// Biến xử lý nút bấm
static volatile bool button_pressed_flag = false;
static int64_t last_button_time = 0;

// ==========================================
// 3. XỬ LÝ NÚT BẤM & LOGIC
// ==========================================

// Ngắt (ISR) cho nút bấm
static void IRAM_ATTR gpio_isr_handler(void* arg) {
    int64_t now = esp_timer_get_time() / 1000;
    if (now - last_button_time > BUTTON_DEBOUNCE_MS) {
        button_pressed_flag = true;
        last_button_time = now;
    }
}

// Khởi tạo nút bấm
static void init_button(void) {
    gpio_config_t io_conf = {};
    io_conf.intr_type = GPIO_INTR_NEGEDGE; // Nhấn xuống (kéo xuống GND)
    io_conf.pin_bit_mask = (1ULL << GPIO_BUTTON_PIN);
    io_conf.mode = GPIO_MODE_INPUT;
    io_conf.pull_up_en = 1; // Kéo trở lên nguồn (quan trọng)
    io_conf.pull_down_en = 0;
    gpio_config(&io_conf);

    // Cài đặt ngắt
    gpio_install_isr_service(0);
    gpio_isr_handler_add(GPIO_BUTTON_PIN, gpio_isr_handler, (void*) GPIO_BUTTON_PIN);
    ESP_LOGI(TAG, "Button initialized on GPIO %d", GPIO_BUTTON_PIN);
}

// Làm mượt dữ liệu
#define SMOOTH_WINDOW 5
float hr_buf[SMOOTH_WINDOW] = {0};
float spo2_buf[SMOOTH_WINDOW] = {0};
int buf_idx = 0;
float get_smoothed_value(float new_val, float *buffer) {
    buffer[buf_idx] = new_val;
    float sum = 0;
    for(int i=0; i<SMOOTH_WINDOW; i++) sum += buffer[i];
    return sum / SMOOTH_WINDOW;
}

// ==========================================
// 4. GIAO DIỆN (UI)
// ==========================================

static void init_styles(void) {
    lv_style_init(&style_screen);
    lv_style_set_bg_color(&style_screen, UI_COLOR_BG);
    lv_style_set_bg_opa(&style_screen, LV_OPA_COVER);
    lv_style_set_text_font(&style_screen, UI_FONT_SMALL);

    lv_style_init(&style_label_yellow);
    lv_style_set_text_color(&style_label_yellow, UI_COLOR_TEXT_YELLOW);

    lv_style_init(&style_label_green);
    lv_style_set_text_color(&style_label_green, UI_COLOR_ICON_GREEN);

    lv_style_init(&style_label_white);
    lv_style_set_text_color(&style_label_white, UI_COLOR_TEXT_WHITE);

    // Style cho icon pin/bluetooth (dùng Font 20 cho gọn)
    lv_style_init(&style_icon_large);
    lv_style_set_text_font(&style_icon_large, UI_FONT_LARGE); 
}

static void create_top_bar(lv_obj_t *parent, lv_obj_t **bt_icon_ptr, lv_obj_t **bat_icon_ptr) {
    lv_obj_t * bar = lv_obj_create(parent);
    lv_obj_set_size(bar, LV_PCT(100), 35); // Giảm chiều cao thanh topbar
    lv_obj_set_style_bg_opa(bar, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(bar, 0, 0);
    lv_obj_set_flex_flow(bar, LV_FLEX_FLOW_ROW_REVERSE);
    lv_obj_set_flex_align(bar, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_all(bar, 2, 0);
    lv_obj_align(bar, LV_ALIGN_TOP_MID, 0, 0);

    *bat_icon_ptr = lv_label_create(bar);
    lv_label_set_text(*bat_icon_ptr, LV_SYMBOL_BATTERY_FULL);
    lv_obj_add_style(*bat_icon_ptr, &style_icon_large, 0);
    lv_obj_set_style_text_color(*bat_icon_ptr, UI_COLOR_ICON_GREEN, 0);

    *bt_icon_ptr = lv_label_create(bar);
    lv_label_set_text(*bt_icon_ptr, LV_SYMBOL_BLUETOOTH);
    lv_obj_add_style(*bt_icon_ptr, &style_icon_large, 0);
    lv_obj_set_style_text_color(*bt_icon_ptr, UI_COLOR_ICON_WHITE, 0);
    lv_obj_set_style_pad_right(*bt_icon_ptr, 10, 0);
}

// --- Screen 1: Splash ---
static void create_splash_screen(void) {
    scr_splash = lv_obj_create(NULL);
    lv_obj_add_style(scr_splash, &style_screen, 0);

    // Tạm thời dùng Symbol nếu ảnh lỗi, hoặc dùng ô vuông từ mảng dolphin_map
    // Để an toàn, tôi dùng Symbol wifi làm ví dụ logo, bạn thay lại ảnh sau
    lv_obj_t * logo_icon = lv_label_create(scr_splash);
    lv_label_set_text(logo_icon, LV_SYMBOL_WIFI); // Placeholder cho logo cá voi
    lv_obj_set_style_text_font(logo_icon, UI_FONT_HUGE, 0); 
    lv_obj_set_style_text_color(logo_icon, lv_color_hex(0x00AAFF), 0);
    lv_obj_align(logo_icon, LV_ALIGN_TOP_MID, 0, 40);

    lv_obj_t * cont = lv_obj_create(scr_splash);
    lv_obj_set_size(cont, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_opa(cont, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(cont, 0, 0);
    lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(cont, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_align(cont, LV_ALIGN_BOTTOM_MID, 0, -20);

    lv_obj_t * l1 = lv_label_create(cont);
    lv_label_set_text(l1, "Finger-clipped\nmonitoring"); // Xuống dòng cho đỡ tràn
    lv_obj_set_style_text_align(l1, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_add_style(l1, &style_label_white, 0);
    lv_obj_set_style_text_font(l1, UI_FONT_MEDIUM, 0);

    lv_obj_t * l3 = lv_label_create(cont);
    lv_label_set_text(l3, "v1.0.0");
    lv_obj_set_style_text_font(l3, UI_FONT_LARGE, 0);
    lv_obj_add_style(l3, &style_label_white, 0);
    lv_obj_set_style_pad_top(l3, 10, 0);
}

// --- Screen 2: Main Dashboard (Sửa lại layout dọc để không tràn) ---
static void create_main_dashboard(void) {
    scr_main = lv_obj_create(NULL);
    lv_obj_add_style(scr_main, &style_screen, 0);

    create_top_bar(scr_main, &icon_bt_main, &icon_bat_main);

    lv_obj_t * main_col = lv_obj_create(scr_main);
    lv_obj_set_size(main_col, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_pos(main_col, 0, 40);
    lv_obj_set_style_bg_opa(main_col, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(main_col, 0, 0);
    lv_obj_set_flex_flow(main_col, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_style_pad_left(main_col, 5, 0);
    lv_obj_set_scroll_dir(main_col, LV_DIR_NONE);

    // MACRO MỚI: Dùng Layout CỘT (COLUMN) để chữ không bị tràn ngang
    #define CREATE_SENSOR_GROUP_VERTICAL(parent, label_text, val_ptr, unit_text) \
        do { \
            lv_obj_t * grp = lv_obj_create(parent); \
            lv_obj_set_size(grp, LV_PCT(100), LV_SIZE_CONTENT); \
            lv_obj_set_style_bg_opa(grp, LV_OPA_TRANSP, 0); \
            lv_obj_set_style_border_width(grp, 0, 0); \
            lv_obj_set_style_pad_all(grp, 0, 0); \
            lv_obj_set_style_pad_bottom(grp, 10, 0); \
            \
            /* Tiêu đề nằm trên */ \
            lv_obj_t * l = lv_label_create(grp); \
            lv_label_set_text(l, label_text); \
            lv_obj_set_style_text_font(l, UI_FONT_LARGE, 0); /* Font 20 */ \
            lv_obj_add_style(l, &style_label_yellow, 0); \
            lv_obj_align(l, LV_ALIGN_TOP_LEFT, 0, 0); \
            \
            /* Container chứa Số + Đơn vị nằm dưới */ \
            lv_obj_t * cont = lv_obj_create(grp); \
            lv_obj_set_size(cont, LV_SIZE_CONTENT, LV_SIZE_CONTENT); \
            lv_obj_set_layout(cont, LV_LAYOUT_FLEX); \
            lv_obj_set_flex_flow(cont, LV_FLEX_FLOW_ROW); \
            lv_obj_set_flex_align(cont, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_END, LV_FLEX_ALIGN_END);\
            lv_obj_set_style_bg_opa(cont, LV_OPA_TRANSP, 0); \
            lv_obj_set_style_border_width(cont, 0, 0); \
            lv_obj_set_style_pad_all(cont, 0, 0); \
            lv_obj_align(cont, LV_ALIGN_TOP_LEFT, 0, 25); /* Cách tiêu đề 25px */ \
            \
            *val_ptr = lv_label_create(cont); \
            lv_label_set_text(*val_ptr, "-- "); \
            lv_obj_set_style_text_font(*val_ptr, UI_FONT_HUGE, 0); /* Font 28 */ \
            lv_obj_add_style(*val_ptr, &style_label_yellow, 0); \
            \
            lv_obj_t * u = lv_label_create(cont); \
            lv_label_set_text(u, unit_text); \
            lv_obj_set_style_text_font(u, UI_FONT_LARGE, 0); /* Font 20 */ \
            lv_obj_add_style(u, &style_label_yellow, 0); \
            lv_obj_set_style_pad_bottom(u, 2, 0); \
        } while(0)

    CREATE_SENSOR_GROUP_VERTICAL(main_col, "Heart rate:", &lbl_hr_val, "bpm");
    CREATE_SENSOR_GROUP_VERTICAL(main_col, "SpO2:", &lbl_spo2_val, "%");
    CREATE_SENSOR_GROUP_VERTICAL(main_col, "Temperature:", &lbl_temp_val, "°C");

    // Status Group
    lv_obj_t * grp_status = lv_obj_create(main_col);
    lv_obj_set_size(grp_status, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_opa(grp_status, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(grp_status, 0, 0);
    lv_obj_set_style_pad_all(grp_status, 0, 0);

    lv_obj_t * l_stat = lv_label_create(grp_status);
    lv_label_set_text(l_stat, "Status:");
    lv_obj_set_style_text_font(l_stat, UI_FONT_LARGE, 0);
    lv_obj_add_style(l_stat, &style_label_yellow, 0);
    lv_obj_align(l_stat, LV_ALIGN_TOP_LEFT, 0, 0);

    lbl_status_val = lv_label_create(grp_status);
    lv_label_set_text(lbl_status_val, "Stable");
    lv_obj_set_style_text_font(lbl_status_val, UI_FONT_LARGE, 0);
    lv_obj_add_style(lbl_status_val, &style_label_yellow, 0);
    lv_obj_align(lbl_status_val, LV_ALIGN_TOP_LEFT, 0, 25);

    // Overlay "CHECK SENSOR"
    lbl_status_overlay = lv_obj_create(scr_main);
    lv_obj_set_size(lbl_status_overlay, LV_PCT(90), 80);
    lv_obj_center(lbl_status_overlay);
    lv_obj_set_style_bg_color(lbl_status_overlay, UI_COLOR_RED, 0);
    lv_obj_set_style_bg_opa(lbl_status_overlay, LV_OPA_70, 0);
    lv_obj_set_style_border_width(lbl_status_overlay, 3, 0);
    lv_obj_set_style_border_color(lbl_status_overlay, lv_color_white(), 0);
    lv_obj_add_flag(lbl_status_overlay, LV_OBJ_FLAG_HIDDEN);

    lv_obj_t * lbl_warn = lv_label_create(lbl_status_overlay);
    lv_label_set_text(lbl_warn, "CHECK\nSENSOR!");
    lv_obj_set_style_text_font(lbl_warn, UI_FONT_LARGE, 0);
    lv_obj_set_style_text_align(lbl_warn, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_set_style_text_color(lbl_warn, lv_color_white(), 0);
    lv_obj_center(lbl_warn);
}

// --- Screen 3: Secondary Dashboard ---
static void create_secondary_dashboard(void) {
    scr_secondary = lv_obj_create(NULL);
    lv_obj_add_style(scr_secondary, &style_screen, 0);

    create_top_bar(scr_secondary, &icon_bt_sec, &icon_bat_sec);

    lv_obj_t * main_col = lv_obj_create(scr_secondary);
    lv_obj_set_size(main_col, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_pos(main_col, 0, 40);
    lv_obj_set_style_bg_opa(main_col, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(main_col, 0, 0);
    lv_obj_set_flex_flow(main_col, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_style_pad_left(main_col, 5, 0);
    lv_obj_set_style_pad_row(main_col, 20, 0); // Khoảng cách giữa các mục

    // Status
    lv_obj_t * grp_s = lv_obj_create(main_col);
    lv_obj_set_size(grp_s, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_opa(grp_s, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(grp_s, 0, 0);
    lv_obj_set_style_pad_all(grp_s, 0, 0);
    
    lv_obj_t * l_st = lv_label_create(grp_s);
    lv_label_set_text(l_st, "Status:");
    lv_obj_set_style_text_font(l_st, UI_FONT_LARGE, 0);
    lv_obj_add_style(l_st, &style_label_green, 0);
    lv_obj_align(l_st, LV_ALIGN_TOP_LEFT, 0, 0);
    
    lbl_sec_status_val = lv_label_create(grp_s);
    lv_label_set_text(lbl_sec_status_val, "Stable");
    lv_obj_set_style_text_font(lbl_sec_status_val, UI_FONT_LARGE, 0);
    lv_obj_add_style(lbl_sec_status_val, &style_label_yellow, 0);
    lv_obj_align(lbl_sec_status_val, LV_ALIGN_TOP_LEFT, 0, 25);

    // Respiration
    CREATE_SENSOR_GROUP_VERTICAL(main_col, "Respiration:", &lbl_resp_val, "brpm");
    // Đổi màu tiêu đề thành xanh
    lv_obj_t * label_resp_title = lv_obj_get_child(lv_obj_get_parent(lv_obj_get_parent(lbl_resp_val)), 0);
    lv_obj_set_style_text_color(label_resp_title, UI_COLOR_ICON_GREEN, 0);

    // Stress
    lv_obj_t * grp_stress = lv_obj_create(main_col);
    lv_obj_set_size(grp_stress, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_opa(grp_stress, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(grp_stress, 0, 0);
    lv_obj_set_style_pad_all(grp_stress, 0, 0);
    
    lv_obj_t * l_stress = lv_label_create(grp_stress);
    lv_label_set_text(l_stress, "Stress:");
    lv_obj_set_style_text_font(l_stress, UI_FONT_LARGE, 0);
    lv_obj_add_style(l_stress, &style_label_green, 0);
    lv_obj_align(l_stress, LV_ALIGN_TOP_LEFT, 0, 0);

    lbl_stress_val = lv_label_create(grp_stress);
    lv_label_set_text(lbl_stress_val, "NO (20%)");
    lv_obj_set_style_text_font(lbl_stress_val, UI_FONT_LARGE, 0); // Dùng font nhỏ hơn chút để vừa chữ NO (...)
    lv_obj_add_style(lbl_stress_val, &style_label_yellow, 0);
    lv_obj_align(lbl_stress_val, LV_ALIGN_TOP_LEFT, 0, 25);
}

void ui_init(void) {
    init_styles();
    create_splash_screen();
    create_main_dashboard();
    create_secondary_dashboard();
    lv_scr_load(scr_splash);
}

void ui_switch_screen(int screen_index) {
    if(screen_index == 0) lv_scr_load(scr_splash);
    else if(screen_index == 1) lv_scr_load(scr_main);
    else if(screen_index == 2) lv_scr_load(scr_secondary);
}

// Logic cập nhật dữ liệu (Giữ nguyên logic cũ)
void ui_update_data(float hr, float spo2, float temp, float resp, int stress, ui_sensor_status_t status, bool bt_connected, int bat_level, bool charging) {
    // 1. Update Icons
    const char* bat_sym = LV_SYMBOL_BATTERY_FULL;
    lv_color_t bat_col = UI_COLOR_ICON_GREEN;
    if(charging) { bat_sym = LV_SYMBOL_CHARGE; bat_col = UI_COLOR_TEXT_YELLOW; }
    else if(bat_level < 20) { bat_sym = LV_SYMBOL_BATTERY_EMPTY; bat_col = UI_COLOR_RED; }
    
    if(icon_bt_main) lv_label_set_text(icon_bt_main, bt_connected ? LV_SYMBOL_BLUETOOTH : "");
    if(icon_bat_main) { lv_label_set_text(icon_bat_main, bat_sym); lv_obj_set_style_text_color(icon_bat_main, bat_col, 0); }
    if(icon_bt_sec) lv_label_set_text(icon_bt_sec, bt_connected ? LV_SYMBOL_BLUETOOTH : "");
    if(icon_bat_sec) { lv_label_set_text(icon_bat_sec, bat_sym); lv_obj_set_style_text_color(icon_bat_sec, bat_col, 0); }

    // 2. Status Logic
    if (status == UI_STATUS_NO_FINGER) {
        lv_label_set_text(lbl_status_val, "No Finger");
        lv_obj_set_style_text_color(lbl_status_val, UI_COLOR_RED, 0);
        if(lbl_sec_status_val) {
            lv_label_set_text(lbl_sec_status_val, "No Finger");
            lv_obj_set_style_text_color(lbl_sec_status_val, UI_COLOR_RED, 0);
        }
        lv_label_set_text(lbl_hr_val, "-- ");
        lv_label_set_text(lbl_spo2_val, "-- ");
        lv_label_set_text(lbl_temp_val, "-- ");
        if(lbl_resp_val) lv_label_set_text(lbl_resp_val, "-- ");
        lv_obj_clear_flag(lbl_status_overlay, LV_OBJ_FLAG_HIDDEN);
        buf_idx = 0; 
        return;
    } else {
        lv_obj_add_flag(lbl_status_overlay, LV_OBJ_FLAG_HIDDEN);
    }

    hr = get_smoothed_value(hr, hr_buf);
    spo2 = get_smoothed_value(spo2, spo2_buf);
    buf_idx = (buf_idx + 1) % SMOOTH_WINDOW;

    lv_label_set_text_fmt(lbl_hr_val, "%.0f ", hr);
    lv_label_set_text_fmt(lbl_spo2_val, "%.0f ", spo2);
    lv_label_set_text_fmt(lbl_temp_val, "%.1f ", temp);
    if(lbl_resp_val) lv_label_set_text_fmt(lbl_resp_val, "%.0f ", resp);

    if (status == UI_STATUS_SHAKING) {
        lv_label_set_text(lbl_status_val, "Shaking");
        lv_obj_set_style_text_color(lbl_status_val, UI_COLOR_ORANGE, 0);
        if(lbl_sec_status_val) {
             lv_label_set_text(lbl_sec_status_val, "Shaking");
             lv_obj_set_style_text_color(lbl_sec_status_val, UI_COLOR_ORANGE, 0);
        }
        lv_obj_set_style_text_color(lbl_hr_val, UI_COLOR_GREY, 0);
        lv_obj_set_style_text_color(lbl_spo2_val, UI_COLOR_GREY, 0);
        lv_obj_set_style_text_color(lbl_temp_val, UI_COLOR_GREY, 0);
    } else { 
        lv_label_set_text(lbl_status_val, "Stable");
        lv_obj_set_style_text_color(lbl_status_val, UI_COLOR_ICON_GREEN, 0);
        if(lbl_sec_status_val) {
             lv_label_set_text(lbl_sec_status_val, "Stable");
             lv_obj_set_style_text_color(lbl_sec_status_val, UI_COLOR_ICON_GREEN, 0);
        }
        lv_obj_set_style_text_color(lbl_hr_val, UI_COLOR_TEXT_YELLOW, 0);
        if(spo2 < 90.0) lv_obj_set_style_text_color(lbl_spo2_val, UI_COLOR_RED, 0);
        else lv_obj_set_style_text_color(lbl_spo2_val, UI_COLOR_TEXT_YELLOW, 0);
        if(temp > 38.0) lv_obj_set_style_text_color(lbl_temp_val, UI_COLOR_RED, 0);
        else lv_obj_set_style_text_color(lbl_temp_val, UI_COLOR_TEXT_YELLOW, 0);
    }

    if(lbl_stress_val) {
        if (stress > 50) { 
            lv_label_set_text_fmt(lbl_stress_val, "YES (%d%%)", stress);
            lv_obj_set_style_text_color(lbl_stress_val, UI_COLOR_RED, 0);
        } else {
            lv_label_set_text_fmt(lbl_stress_val, "NO (%d%%)", stress);
            lv_obj_set_style_text_color(lbl_stress_val, UI_COLOR_ICON_GREEN, 0);
        }
    }
}

// ==========================================
// 5. DRIVER CALLBACKS & MAIN
// ==========================================

static bool notify_lvgl_flush_ready(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *edata, void *user_ctx)
{
    lv_disp_drv_t *disp_drv = (lv_disp_drv_t *)user_ctx;
    lv_disp_flush_ready(disp_drv);
    return false;
}

static void lvgl_flush_cb(lv_disp_drv_t *drv, const lv_area_t *area, lv_color_t *color_map)
{
    esp_lcd_panel_handle_t panel_handle = (esp_lcd_panel_handle_t) drv->user_data;
    esp_lcd_panel_draw_bitmap(panel_handle, area->x1, area->y1, area->x2 + 1, area->y2 + 1, color_map);
}

static void increase_lvgl_tick(void *arg)
{
    lv_tick_inc(2); 
}

void app_main(void)
{
    // --- Hardware Init ---
    ESP_LOGI(TAG, "Initialize SPI bus");
    spi_bus_config_t buscfg = {
        .sclk_io_num = PIN_NUM_CLK,
        .mosi_io_num = PIN_NUM_MOSI,
        .miso_io_num = PIN_NUM_MISO,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = LCD_H_RES * LCD_V_RES * sizeof(uint16_t),
    };
    ESP_ERROR_CHECK(spi_bus_initialize(LCD_HOST, &buscfg, SPI_DMA_CH_AUTO));

    static lv_disp_drv_t disp_drv;

    ESP_LOGI(TAG, "Install panel IO");
    esp_lcd_panel_io_handle_t io_handle = NULL;
    esp_lcd_panel_io_spi_config_t io_config = {
        .dc_gpio_num = PIN_NUM_DC,
        .cs_gpio_num = PIN_NUM_CS,
        .pclk_hz = 40 * 1000 * 1000,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
        .spi_mode = 0,
        .trans_queue_depth = 10,
        .on_color_trans_done = notify_lvgl_flush_ready,
        .user_ctx = &disp_drv,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)LCD_HOST, &io_config, &io_handle));

    ESP_LOGI(TAG, "Install ST7789 panel driver");
    esp_lcd_panel_handle_t panel_handle = NULL;
    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = PIN_NUM_RST,
        .rgb_endian = LCD_RGB_ENDIAN_RGB,
        .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &panel_config, &panel_handle));

    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_invert_color(panel_handle, true)); 
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(panel_handle, 34, 0)); 
    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(panel_handle, true));

    // Init Button (GPIO 0 - Boot Button)
    init_button();

    // --- LVGL Init ---
    ESP_LOGI(TAG, "Initialize LVGL");
    lv_init();
    lv_color_t *buf1 = heap_caps_malloc(LVGL_BUFFER_SIZE * sizeof(lv_color_t), MALLOC_CAP_DMA);
    assert(buf1);
    static lv_disp_draw_buf_t disp_buf;
    lv_disp_draw_buf_init(&disp_buf, buf1, NULL, LVGL_BUFFER_SIZE);

    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = LCD_H_RES;
    disp_drv.ver_res = LCD_V_RES;
    disp_drv.flush_cb = lvgl_flush_cb;
    disp_drv.draw_buf = &disp_buf;
    disp_drv.user_data = panel_handle;
    lv_disp_drv_register(&disp_drv);

    const esp_timer_create_args_t lvgl_tick_timer_args = {
        .callback = &increase_lvgl_tick,
        .name = "lvgl_tick"
    };
    esp_timer_handle_t lvgl_tick_timer = NULL;
    ESP_ERROR_CHECK(esp_timer_create(&lvgl_tick_timer_args, &lvgl_tick_timer));
    ESP_ERROR_CHECK(esp_timer_start_periodic(lvgl_tick_timer, 2 * 1000));

    // --- UI Init ---
    ESP_LOGI(TAG, "Create UI");
    ui_init();

    // --- Main Loop ---
    int tick_count = 0;
    int current_screen = 0;

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(10)); // 10ms
        lv_timer_handler();
        tick_count++;

        // Xử lý nút bấm (Ưu tiên cờ ngắt)
        if (button_pressed_flag) {
            button_pressed_flag = false;
            
            current_screen++;
            if (current_screen > 2) current_screen = 1;
            
            ESP_LOGI(TAG, "Switching to screen %d", current_screen);
            ui_switch_screen(current_screen);
        }

        // Cập nhật dữ liệu
        if (current_screen != 0 && (tick_count % 50 == 0)) { 
            float hr = 70 + (rand() % 40);
            float spo2 = 92 + (rand() % 8);
            float temp = 36.5 + ((rand() % 25) / 10.0);
            float resp = 16 + (rand() % 4);
            int stress = rand() % 100;
            int bat = rand() % 100;
            bool bt = (rand() % 10) > 2;

            ui_sensor_status_t status = UI_STATUS_STABLE;
            int r = rand() % 100; 
            if (r < 5) status = UI_STATUS_NO_FINGER;
            else if (r < 10) status = UI_STATUS_SHAKING;

            ui_update_data(hr, spo2, temp, resp, stress, status, bt, bat, false);
        }
    }
}